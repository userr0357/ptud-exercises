{
    "count":  60,
    "data":  [
                 {
                     "ExerciseCode":  "CTDL_GT-001",
                     "GradingCriteria":  "1. Xác định đúng độ phức tạp là O(1).\r\n  2. Giải thích được tại sao các phép toán cơ bản được coi là thời gian hằng số.\r\n  3. Bổ sung 1: Chứng minh được tổng thời gian là Max(thời gian nhánh If, thời gian nhánh Else).\r\n  4. Bổ sung 2: Xác định đúng độ phức tạp không gian (Space Complexity) là O(1)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-002",
                     "GradingCriteria":  "1. Xác định đúng O(n).\r\n  2. Chỉ ra câu lệnh nào là câu lệnh chủ chốt (dominant operation) được lặp lại n lần.\r\n  3. Bổ sung 1: Giải thích sự phụ thuộc tuyến tính giữa kích thước đầu vào n và số bước thực thi.\r\n  4. Bổ sung 2: Đánh giá bộ nhớ sử dụng không thay đổi theo n (O(1))."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-003",
                     "GradingCriteria":  "1. Xác định đúng O(n).\r\n  2. Giải thích được quy tắc bỏ qua hằng số nhân (1/5 * n vẫn là O(n)).\r\n  3. Bổ sung 1: Thiết lập được biểu thức toán học tính số lần lặp chính xác (n/5).\r\n  4. Bổ sung 2: Phân biệt được sự khác biệt giữa số lần lặp thực tế và bậc tng trưởng (Rate of growth)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-004",
                     "GradingCriteria":  "1. Chỉ ra Best case là O(1) và Worst case là O(n).\r\n  2. Giải thích được điều kiện xảy ra của từng trường hợp.\r\n  3. Bổ sung 1: Tính toán độ phức tạp trung bình (Average case) nếu giả định x nằm ngẫu nhiên.\r\n  4. Bổ sung 2: Đánh giá ảnh hưởng của việc mảng đã sắp xếp hay chưa đối với thuật toán này.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-005",
                     "GradingCriteria":  "1. Xác định đúng O(n^2).\r\n  2. Sử dụng quy tắc nhân để giải thích (n lần của n bước).\r\n  3. Bổ sung 1: Vẽ được mô hình lưới (grid) thể hiện số lần thực thi các câu lệnh bên trong.\r\n  4. Bổ sung 2: Đánh giá sự bùng nổ thời gian khi n tng lên gấp đôi (thời gian tng gấp 4)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-006",
                     "GradingCriteria":  "1. Chứng minh tổng số lần lặp là n*(n+1)/2.\r\n  2. Kết luận đúng bậc cao nhất là O(n^2).\r\n  3. Bổ sung 1: Giải thích quy tắc bỏ qua các thành phần bậc thấp (n/2) và hệ số (1/2).\r\n  4. Bổ sung 2: So sánh hiệu nng thực tế với Bài 5 (nhanh hơn khoảng 2 lần nhưng cùng bậc Big O)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-007",
                     "GradingCriteria":  "1. Giải thích tại sao số lần lặp là log2(n).\r\n  2. Kết luận O(log n).\r\n  3. Bổ sung 1: Chỉ ra được tốc độ tng trưởng cực chậm của hàm Logarit khi n rất lớn.\r\n  4. Bổ sung 2: Xác định điều kiện dừng của vòng lặp dưới dạng bất phương trình toán học."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-008",
                     "GradingCriteria":  "1. Xác định đúng O(n^2).\r\n  2. Phân tích được số phép so sánh và số phép hoán vị.\r\n  3. Bổ sung 1: Đánh giá độ phức tạp không gian (In-place sorting) là O(1).\r\n  4. Bổ sung 2: Phân tích trường hợp tốt nhất của Bubble Sort khi có biến cờ hiệu (flag).\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 3: MỨC ĐỘ KHÓ (HARD)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-009",
                     "GradingCriteria":  "1. Xác định đúng độ phức tạp thời gian O(n).\r\n  2. Xác định đúng độ phức tạp không gian O(n).\r\n  3. Bổ sung 1: Giải thích cơ chế Stack Frame dẫn đến tiêu tốn bộ nhớ trong đệ quy.\r\n  4. Bổ sung 2: So sánh với phương pháp dùng vòng lặp (O(1) không gian)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-010",
                     "GradingCriteria":  "1. Chứng minh số lượng lời gọi hàm tng theo hàm mũ O(2^n).\r\n  2. Giải thích sự lặp lại lãng phí trong các nhánh cây đệ quy.\r\n  3. Bổ sung 1: Xác định chiều cao tối đa của cây đệ quy để suy ra Space Complexity O(n).\r\n  4. Bổ sung 2: Đề xuất phương pháp tối ưu (Quy hoạch động) để giảm về O(n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-011",
                     "GradingCriteria":  "1. Kết luận O(log n).\r\n  2. Giải thích cơ chế loại bỏ một nửa dữ liệu sau mỗi bước.\r\n  3. Bổ sung 1: Chứng minh bằng phương pháp thế (Substitution method) trong toán học.\r\n  4. Bổ sung 2: Đánh giá Space Complexity cho cả hai phiên bản: Đệ quy (O(log n)) và Vòng lặp (O(1))."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-012",
                     "GradingCriteria":  "1. Chỉ ra tại sao đệ quy biến thành T(n) = T(n-1) + O(n).\r\n  2. Kết luận Worst case là O(n^2).\r\n  3. Bổ sung 1: Phân tích độ phức tạp không gian trong trường hợp xấu nhất (O(n)).\r\n  4. Bổ sung 2: Đề xuất giải pháp chọn Pivot ngẫu nhiên (Randomized Quick Sort) để đạt O(n log n).\r\n\r\n\r\n\r\n\r\nDANH SÁCH BÀI TẬP CẤU TRÚC DỮ LIỆU VÀ GIẢI THUẬT\r\nDẠNG 2: CÁC THUẬT TOÁN SẮP XẾP VÀ TÌM KIẾM\r\n------------------------------------------------------------\r\n\r\nPHẦN 1: MỨC ĐỘ DỄ (EASY)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-013",
                     "GradingCriteria":  "1. Cài đặt đúng vòng lặp duyệt toàn bộ mảng từ chỉ số 0 đến n-1.\r\n  2. Thực hiện so sánh chính xác và thoát vòng lặp ngay khi tìm thấy kết quả.\r\n  3. Xử lý đúng trường hợp mảng rỗng hoặc giá trị x không tồn tại.\r\n  4. Đạt độ phức tạp thời gian O(n) cho trường hợp xấu nhất."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-014",
                     "GradingCriteria":  "1. Cấu trúc hai vòng lặp for lồng nhau với chỉ số i chạy từ 0 và j chạy từ i+1 chính xác.\r\n  2. Thực hiện hàm hoán vị (swap) đúng kỹ thuật để không làm mất dữ liệu.\r\n  3. Đảm bảo mảng kết quả được sắp xếp đúng thứ tự yêu cầu.\r\n  4. Xác định đúng độ phức tạp thời gian là O(n^2)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-015",
                     "GradingCriteria":  "1. Cài đặt đúng vòng lặp so sánh cặp phần tử a[j] và a[j+1].\r\n  2. Giảm dần phạm vi xét của vòng lặp bên trong sau mỗi lần lặp bên ngoài để tối ưu.\r\n  3. Thực hiện hoán vị đúng điều kiện khi phần tử đứng trước lớn hơn phần tử đứng sau.\r\n  4. Mô phỏng được các bước trung gian của mảng một cách logic."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-016",
                     "GradingCriteria":  "1. Tìm chính xác vị trí của phần tử nhỏ nhất trong mỗi lượt lặp.\r\n  2. Chỉ thực hiện hoán vị bên ngoài vòng lặp tìm kiếm (tối đa n-1 lần hoán vị).\r\n  3. Đảm bảo tính ổn định của thuật toán trên các bộ dữ liệu mẫu.\r\n  4. Chứng minh được số lần hoán đổi ít hơn so với Interchange Sort.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-017",
                     "GradingCriteria":  "1. Xác định đúng điều kiện dừng của vòng lặp là khi left vượt quá right.\r\n  2. Cập nhật chỉ số left và right chính xác sau mỗi lần so sánh giá trị tại mid.\r\n  3. Xử lý được trường hợp giá trị tìm thấy nằm ở ngay các đầu mảng hoặc chính giữa.\r\n  4. Đạt độ phức tạp thời gian O(log n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-018",
                     "GradingCriteria":  "1. Sử dụng biến tạm để lưu giá trị phần tử đang được \"chèn\".\r\n  2. Thực hiện dời chỗ (shift) các phần tử phía trước một cách chính xác mà không ghi đè mất dữ liệu.\r\n  3. Xử lý đúng điều kiện dừng của vòng lặp tìm vị trí chèn (khi gặp phần tử nhỏ hơn hoặc chạm đầu mảng).\r\n  4. Phân tích được ưu điểm O(n) khi mảng đầu vào đã gần như được sắp xếp."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-019",
                     "GradingCriteria":  "1. Thiết lập đúng điều kiện cơ sở (điểm dừng) để tránh đệ quy vô tận.\r\n  2. Truyền tham số chỉ số mảng chính xác trong các lời gọi đệ quy nhánh trái/phải.\r\n  3. Hàm trả về đúng kết quả từ các tầng đệ quy sâu nhất lên gốc.\r\n  4. Đánh giá được độ phức tạp không gian O(log n) do sử dụng Stack đệ quy."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-020",
                     "GradingCriteria":  "1. Đặt biến cờ hiệu ở đầu mỗi lượt lặp lớn một cách chính xác.\r\n  2. Cập nhật trạng thái cờ hiệu ngay khi có phép hoán vị xảy ra.\r\n  3. Thoát khỏi chương trình sắp xếp ngay sau lượt lặp không có hoán vị.\r\n  4. Chứng minh được thời gian chạy thực tế giảm đáng kể trên dữ liệu gần như đã sắp xếp.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 3: MỨC ĐỘ KHÓ (HARD)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-021",
                     "GradingCriteria":  "1. Thực hiện đúng logic phân hoạch để đưa chốt về đúng vị trí cuối cùng của nó.\r\n  2. Gọi đệ quy chính xác cho các mảng con trái và phải của chốt.\r\n  3. Đảm bảo tính chất: mọi phần tử bên trái chốt nhỏ hơn chốt, bên phải chốt lớn hơn chốt.\r\n  4. Phân tích được trường hợp xấu nhất O(n^2) và cách khắc phục bằng việc chọn chốt ngẫu nhiên."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-022",
                     "GradingCriteria":  "1. Cài đặt hàm trộn (Merge) chính xác, xử lý tốt các phần tử còn dư của hai mảng con.\r\n  2. Quản lý bộ nhớ mảng tạm hợp lý, đảm bảo giải phóng sau khi sử dụng.\r\n  3. Thực hiện chia đôi mảng chính xác tại vị trí mid để gọi đệ quy.\r\n  4. Xác định đúng độ phức tạp thời gian luôn là O(n log n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-023",
                     "GradingCriteria":  "1. Xây dựng đúng cấu trúc Max-Heap từ mảng ban đầu.\r\n  2. Thực hiện chính xác quy trình: hoán đổi gốc với phần tử cuối và gọi lại Heapify.\r\n  3. Quản lý các chỉ số nút cha, nút con trên mảng một cách chính xác.\r\n  4. Đánh giá được ưu điểm không tốn thêm bộ nhớ O(n) như Merge Sort nhưng vẫn đạt O(n log n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-024",
                     "GradingCriteria":  "1. Tái sử dụng thành công hàm phân hoạch (Partition).\r\n  2. Chỉ thực hiện lời gọi đệ quy vào một bên của mảng dựa trên so sánh giữa vị trí chốt và k.\r\n  3. Kết quả trả về phải chính xác so với việc sắp xếp mảng rồi lấy phần tử ở vị trí k.\r\n  4. Giải thích được tại sao độ phức tạp trung bình của phương pháp này là O(n).\r\n\r\n\r\nDANH SÁCH BÀI TẬP CẤU TRÚC DỮ LIỆU VÀ GIẢI THUẬT\r\nDẠNG 3: NGN XẾP (STACK) VÀ HÀNG ĐỢI (QUEUE)\r\n------------------------------------------------------------\r\n\r\nPHẦN 1: MỨC ĐỘ DỄ (EASY)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-025",
                     "GradingCriteria":  "1. Khai báo cấu trúc và khởi tạo chỉ số đỉnh (Top) ở giá trị -1 chính xác.\r\n  2. Xử lý ngn chặn lỗi tràn ngn xếp (Stack Overflow) khi thực hiện push.\r\n  3. Xử lý ngn chặn lỗi lấy dữ liệu từ ngn xếp rỗng (Stack Underflow) khi thực hiện pop.\r\n  4. Đảm bảo các thao tác push/pop hoạt động với độ phức tạp thời gian O(1)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-026",
                     "GradingCriteria":  "1. Quản lý đúng hai chỉ số Front (đầu) và Rear (cuối) trên mảng.\r\n  2. Thực hiện chính xác việc dịch chuyển các chỉ số khi thêm hoặc lấy phần tử.\r\n  3. Đảm bảo nguyên tắc FIFO được thực thi nghiêm ngặt trong mọi tình huống.\r\n  4. Kiểm soát tốt các điều kiện biên khi hàng đợi rỗng hoặc đầy."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-027",
                     "GradingCriteria":  "1. Xử lý nhập liệu tốt, bao gồm cả các chuỗi có khoảng trắng.\r\n  2. Đẩy và lấy đúng, đủ toàn bộ ký tự vào/ra khỏi Stack.\r\n  3. Chuỗi kết quả phải đảo ngược hoàn toàn so với chuỗi ban đầu và có ký tự kết thúc chuỗi hợp lệ.\r\n  4. Đạt hiệu suất thời gian O(n) với n là chiều dài chuỗi."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-028",
                     "GradingCriteria":  "1. Cài đặt thành công cả hai cấu trúc dữ liệu trong cùng một bài toán.\r\n  2. Thực hiện việc đẩy và lấy dữ liệu đồng bộ giữa Stack và Queue.\r\n  3. Đưa ra kết luận chính xác cho nhiều loại chuỗi khác nhau (độ dài chẵn, lẻ).\r\n  4. Đánh giá được độ phức tạp không gian O(n) do sử dụng thêm bộ nhớ phụ.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-029",
                     "GradingCriteria":  "1. Phân loại đúng các loại dấu ngoặc và chỉ đẩy dấu ngoặc mở vào Stack.\r\n  2. So khớp chính xác cặp dấu ngoặc tương ứng (ví dụ: \u0027[\u0027 phải đi với \u0027]\u0027).\r\n  3. Xử lý được trường hợp Stack còn dư phần tử sau khi đã duyệt hết biểu thức.\r\n  4. Giải thuật xử lý được biểu thức có độ dài lớn với thời gian O(n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-030",
                     "GradingCriteria":  "1. Sử dụng công thức toán học (index + 1) % MAX để dịch chuyển các chỉ số.\r\n  2. Xử lý chính xác logic để phân biệt giữa trạng thái \"Hàng đợi đầy\" và \"Hàng đợi rỗng\".\r\n  3. Đảm bảo dữ liệu cũ không bị ghi đè khi hàng đợi thực sự đã đầy.\r\n  4. Chứng minh được việc tiết kiệm không gian bộ nhớ so với Queue thông thường."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-031",
                     "GradingCriteria":  "1. Thực hiện đúng thuật toán chia lấy dư và cập nhật giá trị n.\r\n  2. Lưu trữ đầy đủ các bit nhị phân vào Stack.\r\n  3. Kết quả in ra màn hình phải đúng định dạng số nhị phân.\r\n  4. Xử lý thành công trường hợp đầu vào là số 0."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-032",
                     "GradingCriteria":  "1. Thao tác thêm và lấy phần tử đạt độ phức tạp O(1).\r\n  2. Quản lý con trỏ pTop chính xác, không làm mất dấu địa chỉ đỉnh Stack.\r\n  3. Cấp phát và giải phóng bộ nhớ động đúng cách, không để xảy ra rò rỉ bộ nhớ.\r\n  4. Xử lý an toàn khi người dùng cố gắng lấy phần tử từ Stack rỗng.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 3: MỨC ĐỘ KHÓ (HARD)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-033",
                     "GradingCriteria":  "1. Xây dựng đúng hàm xác định độ ưu tiên cho các toán tử phổ biến.\r\n  2. Xử lý chính xác sự xuất hiện của các dấu ngoặc đơn lồng nhau.\r\n  3. Kết quả chuỗi hậu tố phải đúng quy tắc toán học.\r\n  4. Giải thích được luồng dữ liệu của Stack trong quá trình chuyển đổi."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-034",
                     "GradingCriteria":  "1. Xác định đúng thứ tự các toán hạng khi lấy ra từ Stack (phần tử lấy ra trước là toán hạng thứ hai).\r\n  2. Thực hiện chính xác các phép toán cơ bản (+, -, *, /).\r\n  3. Xử lý được các biểu thức có giá trị số lớn hoặc số có nhiều chữ số.\r\n  4. Chứng minh thuật toán hoạt động với độ phức tạp O(n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-035",
                     "GradingCriteria":  "1. Thiết kế cấu trúc dữ liệu lưu trữ được cả giá trị và độ ưu tiên.\r\n  2. Đảm bảo phần tử có độ ưu tiên cao nhất luôn được lấy ra đầu tiên.\r\n  3. Duy trì tính ổn định (FIFO) cho các phần tử có cùng độ ưu tiên.\r\n  4. Đánh giá được hiệu suất thời gian của thao tác thêm/xóa."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-036",
                     "GradingCriteria":  "1. Thực hiện đúng cơ chế đảo ngược dữ liệu giữa hai Stack để đạt được tính chất FIFO.\r\n  2. Đảm bảo tính nhất quán của dữ liệu trong suốt quá trình chuyển đổi qua lại.\r\n  3. Xử lý tốt các tình huống hàng đợi rỗng.\r\n  4. Phân tích được tại sao chi phí cho mỗi phần tử khi tính trung bình (Amortized) vẫn là O(1).\r\n\r\n\r\n\r\nDANH SÁCH BÀI TẬP CẤU TRÚC DỮ LIỆU VÀ GIẢI THUẬT\r\nDẠNG 4: CÂY NHỊ PHÂN TÌM KIẾM (BST)\r\n------------------------------------------------------------\r\n\r\nPHẦN 1: MỨC ĐỘ DỄ (EASY)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-037",
                     "GradingCriteria":  "1. Khai báo đúng cấu trúc Node và con trỏ gốc (Root).\r\n  2. Thực hiện chính xác việc so sánh giá trị để quyết định chèn vào bên trái hay bên phải.\r\n  3. Xử lý đúng trường hợp cây đang rỗng.\r\n  4. Đảm bảo các Node mới luôn được thêm vào vị trí lá (leaf)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-038",
                     "GradingCriteria":  "1. Xác định đúng điểm dừng đệ quy khi gặp Node NULL.\r\n  2. Thực hiện đúng thứ tự gọi hàm đệ quy cho nhánh trái, xử lý gốc, rồi đến nhánh phải.\r\n  3. Kết quả in ra phải là một dãy số tng dần.\r\n  4. Đạt độ phức tạp thời gian O(n) với n là số Node."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-039",
                     "GradingCriteria":  "1. Thực hiện đúng thứ tự các bước duyệt cho cả hai hàm.\r\n  2. Phân biệt được sự khác nhau về vị trí của Node gốc trong kết quả xuất ra.\r\n  3. Xử lý tốt các cây có cấu trúc lệch về một phía.\r\n  4. Đánh giá được độ phức tạp không gian dựa trên chiều cao của cây."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-040",
                     "GradingCriteria":  "1. Tận dụng tính chất của BST để loại bỏ một nửa số Node cần xét sau mỗi bước so sánh.\r\n  2. Cài đặt đúng bằng phương pháp đệ quy hoặc vòng lặp.\r\n  3. Trả về kết quả chính xác trong mọi trường hợp (có hoặc không tìm thấy).\r\n  4. Phân tích độ phức tạp thời gian đạt mức O(log n) trong trường hợp cây cân bằng.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-041",
                     "GradingCriteria":  "1. Duyệt liên tục về phía bên trái để tìm giá trị Min.\r\n  2. Duyệt liên tục về phía bên phải để tìm giá trị Max.\r\n  3. Xử lý trường hợp cây chỉ có một Node hoặc cây rỗng.\r\n  4. Thực hiện thuật toán với độ phức tạp thời gian phụ thuộc vào chiều cao cây h."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-042",
                     "GradingCriteria":  "1. Sử dụng đệ quy để tổng hợp kết quả từ các cây con.\r\n  2. Xác định đúng điều kiện của Node lá (left == NULL và right == NULL).\r\n  3. Kết quả đếm phải chính xác cho mọi hình dạng cây.\r\n  4. Đảm bảo duyệt qua mỗi Node đúng một lần (O(n))."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-043",
                     "GradingCriteria":  "1. Sử dụng hàm trả về giá trị lớn nhất (Max) giữa chiều cao nhánh trái và nhánh phải.\r\n  2. Công thức tính chiều cao tại một Node phải bằng 1 + Max(H_trái, H_phải).\r\n  3. Xác định đúng chiều cao của cây rỗng là 0 (hoặc -1 tùy quy ước).\r\n  4. Phân tích được tầm quan trọng của chiều cao đối với độ phức tạp thuật toán."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-044",
                     "GradingCriteria":  "1. Kiểm tra điều kiện ràng buộc về khoảng giá trị (min, max) cho từng Node.\r\n  2. Đảm bảo kiểm tra đệ quy xuống tận các Node lá.\r\n  3. Không mắc lỗi chỉ kiểm tra quan hệ cha-con trực tiếp mà quên mất các tổ tiên phía trên.\r\n  4. Trả về kết quả Boolean chính xác.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 3: MỨC ĐỘ KHÓ (HARD)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-045",
                     "GradingCriteria":  "1. Giải phóng bộ nhớ đúng cách sau khi xóa.\r\n  2. Với trường hợp Node có hai con, phải tìm được Node thay thế (thường là Node cực trái của cây con phải).\r\n  3. Duy trì được tính chất BST của cây sau khi thực hiện thao tác xóa.\r\n  4. Xử lý chính xác việc cập nhật con trỏ của Node cha."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-046",
                     "GradingCriteria":  "1. Xử lý trường hợp Node có cây con phải (tìm Min của cây con phải).\r\n  2. Xử lý trường hợp Node không có cây con phải (truy ngược về các tổ tiên).\r\n  3. Thuật toán không được duyệt lại từ gốc để đảm bảo hiệu suất.\r\n  4. Trả về NULL nếu Node đó là giá trị lớn nhất trong cây."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-047",
                     "GradingCriteria":  "1. Sử dụng kỹ thuật chia để trị, chọn phần tử giữa mảng làm gốc.\r\n  2. Gọi đệ quy cho hai nửa mảng còn lại để làm cây con trái và phải.\r\n  3. Cây kết quả phải có sự cân bằng về chiều cao giữa các nhánh.\r\n  4. Đạt độ phức tạp O(n) cho quá trình xây dựng."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-048",
                     "GradingCriteria":  "1. Tận dụng tính chất BST để hướng con trỏ duyệt về phía chứa cả hai Node p và q.\r\n  2. Xác định điểm dừng khi p và q nằm ở hai phía của Node hiện tại (hoặc Node hiện tại trùng với p hoặc q).\r\n  3. Thuật toán hoạt động hiệu quả mà không cần dùng thêm bộ nhớ phụ.\r\n  4. Giải thích được logic tìm kiếm dựa trên so sánh giá trị.\r\n\r\n\r\nDANH SÁCH BÀI TẬP CẤU TRÚC DỮ LIỆU VÀ GIẢI THUẬT\r\nDẠNG 5: ĐỒ THỊ (GRAPH)\r\n------------------------------------------------------------\r\n\r\nPHẦN 1: MỨC ĐỘ DỄ (EASY)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-049",
                     "GradingCriteria":  "1. Khai báo đúng mảng hai chiều và quản lý số lượng đỉnh chính xác.\r\n  2. Xử lý đúng tính chất đối xứng nếu là đồ thị vô hướng (gán cả A[i][j] và A[j][i]).\r\n  3. Kiểm tra điều kiện chỉ số đỉnh hợp lệ trước khi thao tác trên ma trận.\r\n  4. Đạt độ phức tạp không gian O(n^2)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-050",
                     "GradingCriteria":  "1. Duyệt qua ma trận kề mà không bỏ sót hoặc lặp lại cạnh (đối với đồ thị vô hướng).\r\n  2. Lưu trữ thông tin cạnh vào mảng hoặc danh sách liên kết một cách khoa học.\r\n  3. Xuất kết quả danh sách cạnh theo đúng định dạng (u, v).\r\n  4. Phân tích được khi nào nên dùng danh sách cạnh thay vì ma trận kề."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-051",
                     "GradingCriteria":  "1. Duyệt đúng hàng hoặc cột tương ứng trên ma trận kề để đếm số cạnh.\r\n  2. Phân biệt chính xác giữa bậc vào (in-degree) và bậc ra (out-degree) đối với đồ thị có hướng.\r\n  3. Xử lý đúng trường hợp đỉnh cô lập (bậc bằng 0).\r\n  4. Đạt độ phức tạp thời gian O(n) cho mỗi đỉnh cần tính."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-052",
                     "GradingCriteria":  "1. Sử dụng mảng các con trỏ (Head) để quản lý danh sách liên kết cho từng đỉnh.\r\n  2. Thêm Node mới vào danh sách liên kết một cách chính xác (thường thêm vào đầu để đạt O(1)).\r\n  3. Đảm bảo giải phóng bộ nhớ động của các danh sách liên kết khi kết thúc.\r\n  4. Đánh giá được ưu điểm về bộ nhớ O(n + e) so với ma trận kề.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-053",
                     "GradingCriteria":  "1. Sử dụng mảng đánh dấu (Visited) để không thm lại các đỉnh đã xử lý.\r\n  2. Quản lý đúng thứ tự đưa vào và lấy ra khỏi Queue theo nguyên tắc FIFO.\r\n  3. Đảm bảo thm hết các đỉnh trong cùng một thành phần liên thông.\r\n  4. Đạt độ phức tạp thời gian O(n + e)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-054",
                     "GradingCriteria":  "1. Thực hiện đúng cơ chế đệ quy hoặc quản lý Stack để quay lui chính xác.\r\n  2. Sử dụng mảng Visited để tránh lặp vô hạn trong đồ thị có chu trình.\r\n  3. Xử lý thm được toàn bộ các đỉnh ngay cả khi đồ thị không liên thông.\r\n  4. Giải thích được sự khác biệt về thứ tự thm đỉnh so với BFS."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-055",
                     "GradingCriteria":  "1. Chạy thuật toán duyệt nhiều lần cho đến khi tất cả các đỉnh đều được đánh dấu thm.\r\n  2. Đếm chính xác số lần gọi hàm duyệt (mỗi lần gọi tương ứng một thành phần liên thông).\r\n  3. Đưa ra kết luận đúng về tính liên thông của đồ thị đầu vào.\r\n  4. Đạt hiệu suất O(n + e) cho toàn bộ quá trình kiểm tra."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-056",
                     "GradingCriteria":  "1. Sử dụng mảng lưu vết (Parent) để ghi nhớ đỉnh trước đó của mỗi đỉnh khi duyệt.\r\n  2. Truy ngược từ v về u dựa trên mảng Parent để tìm đường đi.\r\n  3. Đảm bảo đường đi tìm được là ngắn nhất (về số cạnh).\r\n  4. Xử lý tốt trường hợp u và v nằm ở hai thành phần liên thông khác nhau.\r\n\r\n------------------------------------------------------------\r\n\r\nPHẦN 3: MỨC ĐỘ KHÓ (HARD)"
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-057",
                     "GradingCriteria":  "1. Quản lý đúng mảng khoảng cách (Distance) và mảng đánh dấu các đỉnh đã tối ưu.\r\n  2. Thực hiện chính xác bước \"Thư giãn cạnh\" (Relaxation) để cập nhật khoảng cách nhỏ hơn.\r\n  3. Tìm được đỉnh có khoảng cách nhỏ nhất trong số các đỉnh chưa xét ở mỗi bước (sử dụng mảng hoặc Priority Queue).\r\n  4. Đạt độ phức tạp O(n^2) hoặc O(e log n)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-058",
                     "GradingCriteria":  "1. Bắt đầu từ một đỉnh bất kỳ và luôn chọn cạnh nhỏ nhất nối từ tập đỉnh đã xét ra tập đỉnh chưa xét.\r\n  2. Đảm bảo cây khung tìm được có đúng (n-1) cạnh và liên thông.\r\n  3. Cập nhật đúng mảng trọng số nhỏ nhất kết nối tới từng đỉnh.\r\n  4. Giải thích được sự khác biệt giữa MST và bài toán đường đi ngắn nhất."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-059",
                     "GradingCriteria":  "1. Đối với đồ thị có hướng: Sử dụng mảng đánh dấu trạng thái (trắng, xám, đen) để phát hiện cạnh ngược (back edge).\r\n  2. Đối với đồ thị vô hướng: Kiểm tra nếu thm lại một đỉnh đã đánh dấu mà đỉnh đó không phải là cha trực tiếp.\r\n  3. Kết luận chính xác sự tồn tại của chu trình.\r\n  4. Đạt độ phức tạp thời gian O(n + e)."
                 },
                 {
                     "ExerciseCode":  "CTDL_GT-060",
                     "GradingCriteria":  "1. Sử dụng thuật toán xóa dần các đỉnh có bán bậc vào bằng 0 (Thuật toán Kahn) hoặc dựa trên DFS.\r\n  2. Đảm bảo thứ tự xuất ra thỏa mãn: nếu có cạnh từ u đến v thì u luôn đứng trước v.\r\n  3. Phát hiện và thông báo nếu đồ thị có chu trình (không thể sắp xếp tô-pô).\r\n  4. Đánh giá ứng dụng của thuật toán trong việc lập lịch trình."
                 }
             ]
}

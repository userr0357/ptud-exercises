DANH SÁCH BÀI TẬP LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG (OOP)
DẠNG 1: LỚP, ĐỐI TƯỢNG VÀ TÍNH ĐỐNG GÓI
------------------------------------------------------------

PHẦN 1: MỨC ĐỘ DỄ (EASY)

Bài 1: Xây dựng lớp Phân số cơ bản
- Mô tả: Trong toán học, phân số gồm tử số và mẫu số. Việc đóng gói chúng vào một lớp giúp quản lý dữ liệu tập trung và đảm bảo mẫu số luôn khác 0 trước khi thực hiện các phép tính.
- Yêu cầu: Định nghĩa lớp PhanSo với các thuộc tính tử số và mẫu số ở phạm vi private. Viết các hàm: khởi tạo (constructor), nhập phân số, xuất phân số và hàm rút gọn phân số về dạng tối giản.
- Tiêu chí chấm điểm:
  1. Khai báo thuộc tính với phạm vi truy cập private chính xác.
  2. Xử lý logic mẫu số khác 0 trong hàm khởi tạo và hàm nhập.
  3. Cài đặt thuật toán tìm ước chung lớn nhất (UCLN) để rút gọn phân số.
  4. Đảm bảo tính đóng gói bằng cách không cho phép sửa đổi tử/mẫu trực tiếp từ bên ngoài.

Bài 2: Quản lý tọa độ Điểm trong không gian 2D
- Mô tả: Một điểm trên mặt phẳng được xác định bởi hoành độ x và tung độ y. Lớp này là nền tảng để xây dựng các hình học phức tạp hơn như hình tròn hay tam giác.
- Yêu cầu: Xây dựng lớp Diem với các phương thức thiết lập (set), lấy giá trị (get) và phương thức tính khoảng cách giữa hai điểm dựa trên công thức toán học.
- Tiêu chí chấm điểm:
  1. Cài đặt đầy đủ các hàm getter và setter cho hai thuộc tính x và y.
  2. Sử dụng đúng từ khóa 'this' để phân biệt thuộc tính lớp và tham số truyền vào.
  3. Áp dụng đúng công thức tính khoảng cách Euclide.
  4. Viết chương trình chính khởi tạo 2 đối tượng và in ra khoảng cách giữa chúng.

Bài 3: Lớp Hình chữ nhật và tính toán diện tích
- Mô tả: Hình chữ nhật cần quản lý chiều dài và chiều rộng. Việc đóng gói giúp ngăn chặn người dùng nhập vào các kích thước âm, đảm bảo tính đúng đắn cho các phép toán diện tích và chu vi.
- Yêu cầu: Tạo lớp HinhChuNhat có các phương thức kiểm tra tính hợp lệ của dữ liệu đầu vào. Viết hàm tính chu vi và diện tích để trả về kết quả cho người dùng.
- Tiêu chí chấm điểm:
  1. Kiểm tra điều kiện chiều dài, chiều rộng phải lớn hơn 0 khi khởi tạo.
  2. Các hàm tính toán phải trả về giá trị (return) thay vì chỉ in ra màn hình.
  3. Cài đặt hàm hiển thị thông tin hình chữ nhật một cách trực quan.
  4. Thực hiện đóng gói hoàn toàn các thuộc tính kích thước.

Bài 4: Mô phỏng tài khoản ngân hàng đơn giản
- Mô tả: Một tài khoản ngân hàng cần bảo mật số dư. Người dùng chỉ có thể thay đổi số dư thông qua các hành động hợp lệ như nạp tiền hoặc rút tiền thay vì sửa trực tiếp con số đó.
- Yêu cầu: Định nghĩa lớp TaiKhoan với số dư là private. Viết hàm napTien(amount) và rutTien(amount) có kiểm tra điều kiện số dư hiện có.
- Tiêu chí chấm điểm:
  1. Bảo vệ thuộc tính số dư không bị truy cập trái phép từ bên ngoài.
  2. Xử lý lỗi khi số tiền rút lớn hơn số dư hiện tại trong tài khoản.
  3. Cập nhật số dư chính xác sau mỗi giao dịch thành công.
  4. Viết hàm truy vấn số dư để hiển thị thông tin khi cần thiết.

------------------------------------------------------------

PHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)

Bài 5: Quản lý thông tin Sinh viên và xếp loại
- Mô tả: Hệ thống quản lý giáo dục cần lưu trữ MSSV, họ tên và điểm trung bình. Việc đóng gói giúp tự động cập nhật xếp loại học lực mỗi khi điểm số của sinh viên thay đổi.
- Yêu cầu: Xây dựng lớp SinhVien với phương thức xepLoai() tự động trả về "Giỏi", "Khá", "Trung bình" dựa trên thang điểm chuẩn.
- Tiêu chí chấm điểm:
  1. Quản lý bộ nhớ cho thuộc tính họ tên (dùng string hoặc mảng ký tự).
  2. Đảm bảo điểm trung bình nằm trong khoảng từ 0 đến 10.
  3. Logic xếp loại phải phủ hết các trường hợp điểm số.
  4. Sử dụng Constructor để khởi tạo thông tin sinh viên ngay khi tạo đối tượng.

Bài 6: Lớp quản lý Sản phẩm và thuế VAT
- Mô tả: Trong kinh doanh, mỗi sản phẩm có tên, đơn giá và số lượng. Lớp này cần tính toán tổng tiền hàng và tự động cộng thêm thuế giá trị gia tăng (VAT) trước khi xuất hóa đơn.
- Yêu cầu: Thiết kế lớp SanPham có phương thức tính thuế VAT (10% đơn giá) và phương thức tính tổng tiền cuối cùng.
- Tiêu chí chấm điểm:
  1. Đóng gói các thuộc tính đơn giá và số lượng để tránh giá trị âm.
  2. Tính toán chính xác số tiền thuế và tổng tiền phải trả.
  3. Hiển thị thông tin sản phẩm dưới dạng bảng hoặc danh sách đẹp mắt.
  4. Sử dụng hàm khởi tạo để gán giá trị mặc định cho các thuộc tính.

Bài 7: Lớp Thời gian (Giờ - Phút - Giây)
- Mô tả: Dữ liệu thời gian cần có tính logic (phút và giây không vượt quá 60). Lớp này giúp tự động chuẩn hóa dữ liệu khi người dùng nhập vào các con số không hợp lệ.
- Yêu cầu: Tạo lớp ThoiGian với phương thức chuanHoa() để tự động tăng giờ khi phút vượt quá 60 và tăng phút khi giây vượt quá 60.
- Tiêu chí chấm điểm:
  1. Kiểm tra và ràng buộc dữ liệu đầu vào của giờ, phút, giây.
  2. Thực hiện logic toán học chính xác trong hàm chuẩn hóa.
  3. Viết hàm in thời gian theo định dạng chuẩn hh:mm:ss.
  4. Cài đặt phương thức cộng thêm một khoảng giây vào thời gian hiện tại.

Bài 8: Quản lý Ngày tháng năm và năm nhuận
- Mô tả: Việc quản lý ngày tháng rất phức tạp do số ngày trong tháng không giống nhau. Lớp này sẽ bao bọc logic kiểm tra năm nhuận để xác định tính hợp lệ của ngày trong tháng 2.
- Yêu cầu: Viết lớp NgayThang có phương thức kiemTraNamNhuan() và phương thức tìm ngày kế tiếp của một ngày cho trước.
- Tiêu chí chấm điểm:
  1. Kiểm tra tính hợp lệ của ngày dựa trên tháng và năm tương ứng.
  2. Xử lý đúng trường hợp ngày cuối cùng của tháng và ngày cuối cùng của năm.
  3. Cài đặt thuật toán kiểm tra năm nhuận chính xác.
  4. Đóng gói các thuộc tính để ngày tháng không bị gán sai logic (ví dụ ngày 31/04).

------------------------------------------------------------

PHẦN 3: MỨC ĐỘ KHÓ (HARD)

Bài 9: Lớp Đa thức và quản lý mảng động
- Mô tả: Đa thức có bậc n cần lưu trữ một dãy các hệ số. Vì bậc của đa thức có thể thay đổi, việc sử dụng mảng động bên trong lớp đòi hỏi sự quản lý bộ nhớ nghiêm ngặt.
- Yêu cầu: Định nghĩa lớp DaThuc với con trỏ quản lý mảng hệ số. Viết hàm khởi tạo, hàm hủy (Destructor) và phương thức tính giá trị đa thức tại điểm x.
- Tiêu chí chấm điểm:
  1. Cấp phát bộ nhớ động trong Constructor dựa trên bậc của đa thức.
  2. Sử dụng Destructor để giải phóng bộ nhớ, tránh rò rỉ (Memory Leak).
  3. Cài đặt thuật toán Horner để tính giá trị đa thức một cách hiệu quả.
  4. Xử lý việc sao chép đối tượng (Copy Constructor) để tránh lỗi bộ nhớ dùng chung.

Bài 10: Quản lý Danh sách đối tượng (Lớp bao)
- Mô tả: Để quản lý nhiều đối tượng (ví dụ một lớp học gồm nhiều sinh viên), ta cần một lớp "quản lý" để bao bọc mảng các đối tượng đó, cung cấp các tính năng tìm kiếm và sắp xếp.
- Yêu cầu: Tạo lớp DanhSachSinhVien chứa mảng các đối tượng SinhVien. Viết các phương thức thêm sinh viên, tìm sinh viên theo MSSV và sắp xếp danh sách theo điểm.
- Tiêu chí chấm điểm:
  1. Quản lý tốt mối quan hệ giữa lớp bao (Container Class) và lớp thành phần.
  2. Cài đặt thuật toán sắp xếp (như Quick Sort hoặc Selection Sort) ngay bên trong phương thức của lớp.
  3. Xử lý trường hợp danh sách đầy hoặc không tìm thấy sinh viên.
  4. Đảm bảo tính đóng gói của từng sinh viên vẫn được tôn trọng thông qua getter/setter.

Bài 11: Lớp Chuỗi ký tự tự định nghĩa (MyString)
- Mô tả: Tái hiện lại lớp string của hệ thống giúp hiểu sâu về cách quản lý vùng nhớ. Lớp này phải xử lý được việc gán chuỗi và nối chuỗi mà không làm hỏng bộ nhớ.
- Yêu cầu: Xây dựng lớp MyString quản lý mảng char động. Thực hiện kỹ thuật sao chép sâu (Deep Copy) để đảm bảo các đối tượng độc lập về vùng nhớ.
- Tiêu chí chấm điểm:
  1. Cài đặt Copy Constructor để sao chép nội dung thay vì sao chép địa chỉ.
  2. Sử dụng hàm hủy để dọn dẹp bộ nhớ khi đối tượng ra khỏi phạm vi.
  3. Viết phương thức nối hai đối tượng MyString lại với nhau.
  4. Xử lý an toàn các chuỗi rỗng hoặc chuỗi có độ dài cực lớn.

Bài 12: Hệ thống quản lý nhân sự với mã hóa bảo mật
- Mô tả: Trong quản lý nhân sự, thông tin lương và mật khẩu cá nhân cần được bảo vệ cực kỳ nghiêm ngặt. Chỉ những phương thức có quyền hạn mới được phép truy xuất hoặc thay đổi các thông tin này.
- Yêu cầu: Thiết kế lớp NhanVien có các thuộc tính nhạy cảm. Viết phương thức đổi mật khẩu yêu cầu mật khẩu cũ và phương thức tính lương dựa trên các tham số bảo mật.
- Tiêu chí chấm điểm:
  1. Sử dụng triệt để tính đóng gói để giấu các thông tin quan trọng.
  2. Kiểm tra tính xác thực trước khi cho phép thay đổi dữ liệu nhạy cảm.
  3. Tính toán lương dựa trên công thức phức tạp (lương cơ bản, hệ số, phụ cấp).
  4. Viết hàm xuất thông tin nhưng chỉ hiển thị các dữ liệu không nhạy cảm (như tên, bộ phận).



DANH SÁCH BÀI TẬP LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG (OOP)
DẠNG 2: NẠP CHỒNG TOÁN TỬ (OPERATOR OVERLOADING)
------------------------------------------------------------

PHẦN 1: MỨC ĐỘ DỄ (EASY)

Bài 1: Nạp chồng toán tử Nhập/Xuất cho lớp Phân số
- Mô tả: Việc sử dụng các hàm nhập() và xuất() truyền thống thường làm mã nguồn trở nên rời rạc. Bằng cách nạp chồng các toán tử dòng lệnh, bạn có thể thực hiện việc đọc/ghi đối tượng Phân số trực tiếp thông qua cin và cout.
- Yêu cầu: Định nghĩa toán tử >> để nhập tử số, mẫu số và toán tử << để in phân số dưới dạng "tử/mẫu". Cần đảm bảo mẫu số được xử lý khác 0 ngay khi nhập.
- Tiêu chí chấm điểm:
  1. Cài đặt các toán tử dưới dạng hàm bạn (friend function) để truy cập thuộc tính private.
  2. Sử dụng đúng đối tượng istream và ostream làm tham số truyền vào.
  3. Trả về tham chiếu (reference) của luồng để có thể thực hiện nhập/xuất liên tiếp.
  4. Định dạng đầu ra sạch sẽ, dễ đọc.

Bài 2: So sánh hai tọa độ Điểm 2D
- Mô tả: Để kiểm tra hai điểm trong mặt phẳng có trùng nhau hay không, ta cần so sánh cả hoành độ và tung độ. Việc nạp chồng toán tử so sánh giúp mã nguồn ngắn gọn hơn nhiều so với việc gọi hàm so sánh thủ công.
- Yêu cầu: Nạp chồng toán tử == và != cho lớp Diem. Hai điểm được coi là bằng nhau nếu x1 == x2 và y1 == y2.
- Tiêu chí chấm điểm:
  1. Trả về kiểu dữ liệu bool cho các toán tử so sánh.
  2. Sử dụng từ khóa const cho tham số truyền vào để đảm bảo tính an toàn dữ liệu.
  3. Xử lý logic so sánh đầy đủ cả hai thuộc tính x và y.
  4. Đảm bảo toán tử != hoạt động dựa trên phủ định của toán tử ==.

Bài 3: Phép cộng hai Phân số
- Mô tả: Toán tử cộng là phép toán cơ bản nhất. Trong OOP, ta muốn viết "ps3 = ps1 + ps2" thay vì phải gọi hàm tính toán phức tạp. Điều này giúp các biểu thức toán học trong chương trình trở nên tự nhiên.
- Yêu cầu: Nạp chồng toán tử + cho lớp PhanSo. Kết quả trả về phải là một đối tượng Phân số mới đã được rút gọn tối giản.
- Tiêu chí chấm điểm:
  1. Áp dụng đúng công thức quy đồng mẫu số để tính tổng.
  2. Tự động gọi hàm rút gọn (UCLN) trước khi trả về kết quả.
  3. Không làm thay đổi giá trị của hai đối tượng tham gia phép cộng (ps1 và ps2).
  4. Trả về đối tượng theo giá trị (value) để hỗ trợ các biểu thức phức hợp.

Bài 4: Cộng một số nguyên vào Phân số
- Mô tả: Trong toán học, ta có thể lấy một phân số cộng với một số nguyên. Việc nạp chồng toán tử cho trường hợp này giúp chương trình linh hoạt hơn khi xử lý các kiểu dữ liệu hỗn hợp.
- Yêu cầu: Nạp chồng toán tử + để thực hiện phép tính: PhanSo + int. Ví dụ: 1/2 + 1 = 3/2.
- Tiêu chí chấm điểm:
  1. Xử lý logic chuyển đổi số nguyên thành phân số có mẫu bằng 1 trước khi cộng.
  2. Cài đặt toán tử dưới dạng hàm thành viên (member function) của lớp PhanSo.
  3. Trả về kết quả là một đối tượng PhanSo mới.
  4. Đảm bảo tính đúng đắn của tử số và mẫu số sau phép tính.

------------------------------------------------------------

PHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)

Bài 5: Tăng/Giảm thời gian (Toán tử ++ và --)
- Mô tả: Các toán tử tăng giảm rất hữu ích cho các lớp quản lý thời gian hoặc ngày tháng. Bạn cần xử lý cả hai dạng tiền tố (++t) và hậu tố (t++) để đồng bộ với cách hoạt động của kiểu int.
- Yêu cầu: Nạp chồng toán tử ++ và -- cho lớp ThoiGian (giờ, phút, giây). Khi tăng thêm 1 giây, nếu đạt 60 phải tự động tăng phút và giờ tương ứng.
- Tiêu chí chấm điểm:
  1. Phân biệt đúng chữ ký (signature) của toán tử tiền tố và hậu tố (sử dụng tham số int giả cho hậu tố).
  2. Xử lý logic chuẩn hóa thời gian (vòng quay 24h) chính xác.
  3. Trả về đúng kiểu tham chiếu cho tiền tố và giá trị cũ cho hậu tố.
  4. Đảm bảo tính nhất quán của dữ liệu sau khi thực hiện thao tác.

Bài 6: Truy cập phần tử mảng bằng toán tử chỉ số [ ]
- Mô tả: Khi xây dựng một lớp quản lý mảng động, việc sử dụng toán tử [] cho phép người dùng truy cập các phần tử giống như mảng thông thường thay vì phải gọi hàm getElement(i).
- Yêu cầu: Định nghĩa toán tử [] cho lớp MyVector để truy xuất và sửa đổi giá trị phần tử tại vị trí i.
- Tiêu chí chấm điểm:
  1. Kiểm tra điều kiện chỉ số i nằm trong phạm vi hợp lệ của mảng.
  2. Trả về tham chiếu của phần tử để có thể sử dụng ở cả hai vế của phép gán (L-value).
  3. Cài đặt thêm phiên bản const của toán tử [] để dùng cho các đối tượng hằng.
  4. Xử lý lỗi (Exception) hoặc thông báo khi chỉ số vượt quá phạm vi.

Bài 7: Phép toán trên Số phức (Complex Number)
- Mô tả: Số phức gồm phần thực và phần ảo. Việc nạp chồng các toán tử +, -, *, / giúp lớp số phức hoạt động hoàn hảo trong các bài toán kỹ thuật điện và điều khiển.
- Yêu cầu: Cài đặt đầy đủ các toán tử toán học cho lớp SoPhuc. Ngoài ra, nạp chồng toán tử << để in số phức dưới dạng "a + bi".
- Tiêu chí chấm điểm:
  1. Áp dụng đúng công thức nhân/chia số phức (ví dụ nhân liên hợp).
  2. Xử lý hiển thị đẹp mắt các trường hợp phần ảo âm hoặc bằng 0.
  3. Đảm bảo các toán tử không làm thay đổi đối tượng gốc.
  4. Cài đặt logic toán học đạt độ chính xác cao.

Bài 8: So sánh thứ hạng Sinh viên (Toán tử > và <)
- Mô tả: Để sắp xếp danh sách sinh viên, ta cần một tiêu chí so sánh. Việc nạp chồng các toán tử so sánh dựa trên điểm trung bình giúp các thuật toán sắp xếp hoạt động tự động trên đối tượng Sinh viên.
- Yêu cầu: Nạp chồng toán tử > và < cho lớp SinhVien. Nếu hai sinh viên có điểm bằng nhau, thực hiện so sánh tiếp theo mã số sinh viên.
- Tiêu chí chấm điểm:
  1. Thực hiện logic so sánh đa tầng (điểm rồi đến mã số).
  2. Đảm bảo tính bắc cầu và nhất quán của phép so sánh.
  3. Sử dụng tham chiếu hằng để tối ưu tốc độ so sánh.
  4. Viết chương trình mẫu sắp xếp một mảng sinh viên bằng toán tử đã nạp chồng.

------------------------------------------------------------

PHẦN 3: MỨC ĐỘ KHÓ (HARD)

Bài 9: Quản lý bộ nhớ với toán tử gán (Operator =)
- Mô tả: Đối với các lớp sử dụng mảng động, toán tử gán mặc định của hệ thống chỉ sao chép địa chỉ, dẫn đến lỗi dùng chung vùng nhớ. Bạn phải nạp chồng toán tử này để thực hiện sao chép sâu.
- Yêu cầu: Cài đặt toán tử = cho lớp DaThuc hoặc MyString. Phải giải phóng vùng nhớ cũ của đối tượng bên trái trước khi cấp phát vùng nhớ mới để sao chép dữ liệu từ đối tượng bên phải.
- Tiêu chí chấm điểm:
  1. Kiểm tra trường hợp tự gán (ví dụ: a = a) để tránh xóa nhầm dữ liệu đang dùng.
  2. Thực hiện giải phóng bộ nhớ cũ và cấp phát mới chính xác.
  3. Trả về *this để hỗ trợ chuỗi phép gán (a = b = c).
  4. Đảm bảo không xảy ra hiện tượng rò rỉ bộ nhớ sau khi gán.

Bài 10: Toán tử gọi hàm (Toán tử ( )) để tính giá trị Đa thức
- Mô tả: Toán tử () (Function Call Operator) cho phép một đối tượng hoạt động như một hàm số. Điều này rất thú vị khi áp dụng cho lớp đa thức để tính giá trị của nó tại một điểm x cụ thể.
- Yêu cầu: Nạp chồng toán tử () cho lớp DaThuc sao cho lệnh "double result = P(x);" sẽ trả về giá trị của đa thức P tại x.
- Tiêu chí chấm điểm:
  1. Sử dụng thuật toán tối ưu (như lược đồ Horner) để tính toán giá trị.
  2. Cho phép nhận tham số là kiểu số thực (double/float).
  3. Đảm bảo phương thức là hằng (const function) vì không làm thay đổi đa thức.
  4. Xử lý được các đa thức có bậc bằng 0 hoặc đa thức rỗng.

Bài 11: Cộng và Nhân hai Ma trận
- Mô tả: Ma trận là cấu trúc dữ liệu hai chiều phức tạp. Việc nạp chồng các toán tử +, * giúp lớp Matrix thực hiện các phép toán đại số tuyến tính một cách chuyên nghiệp.
- Yêu cầu: Nạp chồng toán tử + và * cho lớp MaTran. Cần kiểm tra điều kiện tương thích về kích thước giữa hai ma trận trước khi thực hiện phép tính.
- Tiêu chí chấm điểm:
  1. Kiểm tra điều kiện: cộng cùng kích thước, nhân (cột A = hàng B).
  2. Cấp phát mảng động cho ma trận kết quả một cách chính xác.
  3. Tối ưu hóa các vòng lặp để phép nhân ma trận đạt hiệu suất tốt nhất.
  4. Xử lý ngoại lệ nếu kích thước ma trận không phù hợp.

Bài 12: Chuyển đổi kiểu dữ liệu (Conversion Operator)
- Mô tả: Đôi khi ta muốn ép kiểu một đối tượng về một kiểu dữ liệu cơ bản (ví dụ: ép kiểu phân số về số thực double). Toán tử chuyển đổi kiểu sẽ thực hiện việc này một cách tự động.
- Yêu cầu: Nạp chồng toán tử chuyển đổi cho lớp PhanSo sang kiểu double và lớp ThoiGian sang kiểu int (tổng số giây).
- Tiêu chí chấm điểm:
  1. Cài đặt đúng cú pháp toán tử chuyển đổi (không có kiểu trả về trong khai báo).
  2. Tính toán chính xác giá trị thực của phân số (lưu ý phép chia nguyên).
  3. Đảm bảo toán tử hoạt động tốt trong các biểu thức tính toán hỗn hợp.
  4. Sử dụng từ khóa explicit nếu cần để tránh chuyển đổi ngầm định gây lỗi logic.


DANH SÁCH BÀI TẬP LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG (OOP)
DẠNG 3: TÍNH KẾ THỪA (INHERITANCE)
------------------------------------------------------------

PHẦN 1: MỨC ĐỘ DỄ (EASY)

Bài 1: Kế thừa cơ bản từ lớp Người sang Sinh viên
- Mô tả: Một sinh viên về bản chất vẫn là một con người nhưng có thêm các đặc tính riêng như mã số sinh viên và điểm số. Việc kế thừa giúp lớp Sinh viên không cần định nghĩa lại các thuộc tính chung như họ tên, ngày sinh hay giới tính.
- Yêu cầu: Định nghĩa lớp Nguoi với các thuộc tính cơ bản. Xây dựng lớp SinhVien kế thừa từ lớp Nguoi và bổ sung thêm thuộc tính MSSV. Viết hàm nhập/xuất cho cả hai lớp.
- Tiêu chí chấm điểm:
  1. Sử dụng đúng cú pháp kế thừa (public) trong C++.
  2. Gọi được phương thức xuất của lớp cha bên trong phương thức xuất của lớp con.
  3. Khai báo đúng phạm vi truy cập (protected) để lớp con có thể sử dụng thuộc tính của lớp cha.
  4. Khởi tạo đối tượng lớp con và hiển thị đầy đủ thông tin từ cả hai lớp.

Bài 2: Kế thừa lớp Hình học cho Hình chữ nhật
- Mô tả: Mọi hình học đều có thuộc tính tên hình. Hình chữ nhật là một trường hợp cụ thể có thêm chiều dài và chiều rộng. Kế thừa giúp quản lý danh mục các loại hình một cách hệ thống.
- Yêu cầu: Tạo lớp cơ sở HinhHoc và lớp dẫn xuất HinhChuNhat. Lớp con kế thừa thuộc tính tên từ lớp cha và định nghĩa thêm các kích thước riêng.
- Tiêu chí chấm điểm:
  1. Thực hiện kế thừa thuộc tính tên từ lớp cha thành công.
  2. Hàm khởi tạo lớp con gán được giá trị cho cả thuộc tính của lớp cha.
  3. Phương thức in thông tin hiển thị được tên hình từ lớp cơ sở.
  4. Phân biệt rõ ràng giữa thuộc tính chung và thuộc tính riêng.

Bài 3: Quản lý Nhân viên và Quản lý (Manager)
- Mô tả: Trong một công ty, Quản lý là một loại nhân viên đặc biệt có thêm phụ cấp trách nhiệm. Kế thừa cho phép ta tận dụng logic tính lương cơ bản của nhân viên cho cấp quản lý.
- Yêu cầu: Xây dựng lớp NhanVien và lớp QuanLy kế thừa từ NhanVien. Lớp QuanLy bổ sung thêm thuộc tính phụ cấp và ghi đè hàm tính lương.
- Tiêu chí chấm điểm:
  1. Cài đặt đúng mối quan hệ kế thừa giữa hai lớp nhân sự.
  2. Hàm tính lương của lớp QuanLy phải gọi được hàm tính lương của lớp NhanVien để cộng thêm phụ cấp.
  3. Sử dụng đúng phạm vi truy cập để bảo vệ dữ liệu lương.
  4. Minh họa được việc thay đổi lương ở lớp cha sẽ ảnh hưởng đến lớp con.

Bài 4: Sử dụng từ khóa Protected trong kế thừa
- Mô tả: Từ khóa protected đóng vai trò quan trọng trong kế thừa, nó cho phép lớp con truy cập dữ liệu nhưng vẫn giữ bí mật với thế giới bên ngoài.
- Yêu cầu: Tạo lớp cha có các thuộc tính protected. Tạo lớp con truy cập trực tiếp các thuộc tính này để thực hiện một phép tính toán cụ thể.
- Tiêu chí chấm điểm:
  1. Chứng minh được thuộc tính protected không thể truy cập từ hàm main.
  2. Lớp con truy cập và thay đổi được giá trị các thuộc tính này mà không cần getter/setter.
  3. Giải thích được sự khác biệt giữa private và protected qua mã nguồn.
  4. Đảm bảo tính đóng gói vẫn được duy trì đối với các đối tượng bên ngoài.

------------------------------------------------------------

PHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)

Bài 5: Kế thừa đa mức (Multilevel Inheritance)
- Mô tả: Trong tự nhiên, phân cấp có thể kéo dài qua nhiều thế hệ. Động vật -> Động vật có vú -> Con người. Mỗi cấp độ sẽ kế thừa và làm giàu thêm các đặc tính của cấp độ trước.
- Yêu cầu: Xây dựng hệ thống 3 lớp kế thừa nối tiếp nhau. Lớp cuối cùng phải sử dụng được thuộc tính và phương thức của cả hai lớp tiền nhiệm.
- Tiêu chí chấm điểm:
  1. Thiết lập đúng chuỗi kế thừa đa mức.
  2. Constructor của lớp cháu phải gọi được Constructor của lớp cha và ông thông qua danh sách khởi tạo.
  3. Không xảy ra lỗi xung đột tên phương thức giữa các cấp.
  4. Chứng minh được tính lan truyền của các thuộc tính protected qua các cấp.

Bài 6: Hệ thống quản lý các loại Cán bộ
- Mô tả: Một đơn vị cần quản lý Công nhân, Kỹ sư và Nhân viên. Cả ba nhóm này đều có chung thông tin cán bộ nhưng khác nhau về chuyên môn (bậc thợ, ngành đào tạo, công việc).
- Yêu cầu: Thiết kế lớp CanBo là lớp cha. Các lớp CongNhan, KySu, NhanVien kế thừa từ CanBo và bổ sung các đặc thù nghề nghiệp tương ứng.
- Tiêu chí chấm điểm:
  1. Thiết kế cấu trúc phân cấp cây kế thừa hợp lý.
  2. Các lớp con tái sử dụng tối đa mã nguồn của lớp cha cho các thông tin chung.
  3. Hàm nhập/xuất của mỗi lớp con chỉ tập trung vào phần dữ liệu riêng biệt của nó.
  4. Quản lý danh sách hỗn hợp các loại cán bộ bằng các đối tượng cụ thể.

Bài 7: Quản lý Phương tiện giao thông
- Mô tả: Ô tô, Xe máy và Xe tải đều có chung số khung, hãng sản xuất và năm xuất xưởng. Việc dùng kế thừa giúp hệ thống quản lý đăng kiểm hoạt động nhất quán trên mọi loại xe.
- Yêu cầu: Xây dựng lớp PhuongTien và các lớp con tương ứng. Mỗi lớp con có thêm thuộc tính riêng (số chỗ ngồi, dung tích bình xăng, tải trọng).
- Tiêu chí chấm điểm:
  1. Định nghĩa các thuộc tính chung tại lớp cơ sở một cách khoa học.
  2. Lớp dẫn xuất bổ sung đúng và đủ các thuộc tính đặc trưng.
  3. Viết hàm hiển thị thông tin tổng hợp cho từng loại phương tiện.
  4. Kiểm soát tốt việc khởi tạo dữ liệu thông qua Constructor có tham số.

Bài 8: Ghi đè phương thức (Method Overriding) trong kế thừa
- Mô tả: Lớp con có thể định nghĩa lại một phương thức đã có ở lớp cha để phù hợp hơn với đặc tính của nó (ví dụ: mọi loài chim đều bay, nhưng chim cánh cụt thì "bay" theo cách bơi).
- Yêu cầu: Tạo lớp cha có hàm hienThi(). Lớp con định nghĩa lại hàm hienThi() để bổ sung thông tin chi tiết hơn mà không làm mất đi thông tin cũ.
- Tiêu chí chấm điểm:
  1. Cài đặt đúng hàm trùng tên và trùng tham số ở cả hai lớp.
  2. Sử dụng toán tử phân giải phạm vi (::) để gọi lại hàm của lớp cha bên trong hàm của lớp con.
  3. Minh họa được việc khi gọi hàm từ đối tượng lớp con, phiên bản mới sẽ được ưu tiên.
  4. Đảm bảo logic hiển thị không bị lặp lại nhàm chán.

------------------------------------------------------------

PHẦN 3: MỨC ĐỘ KHÓ (HARD)

Bài 9: Đa kế thừa và Vấn đề kim cương (Diamond Problem)
- Mô tả: Một lớp có thể kế thừa từ nhiều lớp cha cùng lúc. Tuy nhiên, nếu hai lớp cha cùng kế thừa từ một lớp "ông nội", lớp con sẽ bị xung đột dữ liệu (vấn đề kim cương).
- Yêu cầu: Xây dựng hệ thống đa kế thừa và sử dụng từ khóa 'virtual' trong kế thừa để giải quyết xung đột vùng nhớ.
- Tiêu chí chấm điểm:
  1. Cài đặt thành công một lớp kế thừa từ hai lớp khác nhau.
  2. Sử dụng Virtual Inheritance để đảm bảo chỉ có một bản sao duy nhất của lớp cơ sở chung.
  3. Truy cập thuộc tính của lớp "ông nội" từ lớp con mà không bị lỗi ambiguious (mơ hồ).
  4. Giải thích được cơ chế hoạt động của con trỏ ảo trong trường hợp này.

Bài 10: Quản lý Tài khoản ngân hàng đa dạng
- Mô tả: Tài khoản tiết kiệm có lãi suất, tài khoản tín dụng có hạn mức nợ. Cả hai đều kế thừa từ tài khoản thanh toán nhưng có logic rút tiền và tính phí khác hẳn nhau.
- Yêu cầu: Xây dựng hệ thống kế thừa phức tạp cho ngân hàng. Lớp con phải kiểm tra các ràng buộc riêng (ví dụ: không được rút quá hạn mức nợ) trước khi gọi hàm rút tiền của lớp cha.
- Tiêu chí chấm điểm:
  1. Thiết kế logic ghi đè phương thức rút tiền với các điều kiện ràng buộc chặt chẽ.
  2. Quản lý chính xác số dư sau khi áp dụng các quy tắc lãi suất hoặc phí dịch vụ riêng.
  3. Sử dụng Constructor để truyền dữ liệu xuyên suốt các tầng kế thừa.
  4. Đảm bảo tính an toàn dữ liệu, không cho phép lớp con làm hỏng trạng thái của lớp cha.

Bài 11: Kế thừa và Quản lý bộ nhớ động
- Mô tả: Khi lớp cha và lớp con đều sử dụng mảng động hoặc con trỏ, việc quản lý hàm hủy và sao chép trở nên cực kỳ nguy hiểm nếu không nắm vững quy tắc kế thừa.
- Yêu cầu: Xây dựng hai lớp kế thừa nhau, cả hai đều có thuộc tính là con trỏ. Viết hàm hủy để giải phóng bộ nhớ theo đúng thứ tự.
- Tiêu chí chấm điểm:
  1. Cài đặt Destructor cho cả lớp cha và lớp con.
  2. Đảm bảo bộ nhớ của lớp con được giải phóng trước, sau đó mới đến lớp cha.
  3. Xử lý Copy Constructor ở lớp con sao cho nó cũng sao chép được dữ liệu ở lớp cha.
  4. Ngăn chặn triệt để lỗi Memory Leak và lỗi truy cập vùng nhớ đã giải phóng.

Bài 12: Hệ thống quản lý Sở thú (Zoo Management)
- Mô tả: Một sở thú quản lý nhiều loài Động vật. Mỗi nhóm (Thú, Chim, Bò sát) có đặc điểm chung, nhưng từng loài cụ thể lại có tiếng kêu và thức ăn riêng.
- Yêu cầu: Thiết kế cây kế thừa ít nhất 3 tầng (Động vật -> Nhóm loài -> Loài cụ thể). Lớp cuối cùng phải tổng hợp được đầy đủ hành vi từ các cấp trên.
- Tiêu chí chấm điểm:
  1. Xây dựng cấu trúc kế thừa phân cấp sâu và rõ ràng.
  2. Sử dụng phương thức ghi đè để mô phỏng các hành vi đặc trưng của từng loài.
  3. Constructor các lớp con phải truyền được dữ liệu lên tận lớp cơ sở cao nhất.
  4. Viết chương trình mô phỏng các hoạt động của sở thú thông qua danh sách đối tượng kế thừa.


DANH SÁCH BÀI TẬP LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG (OOP)
DẠNG 4: TÍNH ĐA HÌNH VÀ LỚP TRƯU TƯỢNG
------------------------------------------------------------

PHẦN 1: MỨC ĐỘ DỄ (EASY)

Bài 1: Sử dụng hàm ảo (Virtual Function) cơ bản
- Mô tả: Khi con trỏ lớp cha trỏ đến đối tượng lớp con, mặc định hệ thống sẽ gọi hàm của lớp cha. Việc sử dụng hàm ảo giúp chương trình nhận biết và gọi đúng hàm của lớp con tại thời điểm thực thi (Late Binding).
- Yêu cầu: Tạo lớp cha DongVat có hàm keu(). Các lớp con như Cho, Meo ghi đè hàm này. Sử dụng con trỏ lớp DongVat để gọi hàm keu() và quan sát sự khác biệt khi có và không có từ khóa virtual.
- Tiêu chí chấm điểm:
  1. Khai báo đúng từ khóa virtual tại hàm của lớp cha.
  2. Thực hiện ghi đè (override) chính xác tại các lớp con.
  3. Sử dụng con trỏ lớp cơ sở để quản lý đối tượng lớp dẫn xuất.
  4. Giải thích được cơ chế liên kết động qua kết quả chạy chương trình.

Bài 2: Tạo lớp trừu tượng Hình học đơn giản
- Mô tả: Một "Hình học" nói chung không thể tính diện tích nếu không biết đó là hình gì. Do đó, lớp Hình học nên là một lớp trừu tượng để làm khuôn mẫu cho các hình cụ thể.
- Yêu cầu: Định nghĩa lớp trừu tượng HinhHoc với hàm thuần ảo tinhDienTich() = 0. Xây dựng lớp HinhTron và HinhChuNhat kế thừa và cài đặt hàm này.
- Tiêu chí chấm điểm:
  1. Khai báo đúng cú pháp hàm thuần ảo để biến lớp thành lớp trừu tượng (Abstract Class).
  2. Lớp con phải cài đặt đầy đủ các hàm thuần ảo từ lớp cha.
  3. Không thể khởi tạo đối tượng trực tiếp từ lớp HinhHoc.
  4. Tính toán diện tích chính xác cho từng hình cụ thể.

Bài 3: Quản lý danh sách đối tượng đa hình
- Mô tả: Sức mạnh của đa hình nằm ở việc quản lý một danh sách hỗn hợp các đối tượng khác nhau nhưng có chung lớp cha thông qua một mảng con trỏ duy nhất.
- Yêu cầu: Tạo một mảng con trỏ lớp cha trỏ đến nhiều đối tượng lớp con khác nhau. Sử dụng vòng lặp để gọi phương thức đa hình trên toàn bộ danh sách.
- Tiêu chí chấm điểm:
  1. Khởi tạo mảng con trỏ và cấp phát bộ nhớ động cho các đối tượng con.
  2. Gọi phương thức thông qua con trỏ mà không cần ép kiểu thủ công.
  3. Hiển thị đúng hành vi đặc trưng của từng đối tượng trong danh sách.
  4. Đảm bảo tính nhất quán trong giao diện lập trình của các lớp con.

Bài 4: Lớp trừu tượng và Phương thức thuần ảo
- Mô tả: Phương thức thuần ảo đóng vai trò như một bản thiết kế bắt buộc. Mọi lớp con muốn trở thành một lớp cụ thể đều phải thực hiện lời hứa cài đặt các phương thức này.
- Yêu cầu: Thiết kế lớp trừu tượng ThietBiDien với hàm thuần ảo tinhCongSuat(). Xây dựng các lớp Den, Quat kế thừa và thực thi hàm đó.
- Tiêu chí chấm điểm:
  1. Sử dụng đúng ý nghĩa của phương thức thuần ảo trong thiết kế hệ thống.
  2. Lớp dẫn xuất không cài đặt hàm thuần ảo sẽ tiếp tục là lớp trừu tượng.
  3. Cài đặt logic tính toán công suất riêng cho từng loại thiết bị.
  4. Hiểu rõ sự khác biệt giữa hàm ảo thông thường và hàm thuần ảo.

------------------------------------------------------------

PHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)

Bài 5: Quản lý nhân viên bằng kỹ thuật đa hình
- Mô tả: Trong một công ty có nhân viên biên chế và nhân viên hợp đồng. Cách tính lương của họ khác nhau, nhưng hệ thống kế toán cần duyệt qua tất cả để xuất bảng lương hàng tháng.
- Yêu cầu: Xây dựng lớp cha NhanVien và các lớp con với hàm ảo tinhLuong(). Dùng danh sách con trỏ để quản lý và tính tổng lương cho toàn công ty.
- Tiêu chí chấm điểm:
  1. Thiết kế hàm ảo tinhLuong() phù hợp với các công thức tính lương khác nhau.
  2. Duyệt danh sách và tính tổng tiền lương chính xác bằng một vòng lặp duy nhất.
  3. Quản lý dữ liệu nhân viên thông qua lớp cha mà không quan tâm đến chi tiết lớp con.
  4. Cài đặt các phương thức nhập/xuất đa hình để lấy thông tin nhân viên.

Bài 6: Tính tổng diện tích các hình hỗn hợp
- Mô tả: Một kiến trúc sư cần tính tổng diện tích của một mặt sàn gồm nhiều loại hình khối khác nhau. Đa hình giúp việc cộng dồn diện tích trở nên cực kỳ đơn giản.
- Yêu cầu: Tạo danh sách các đối tượng HinhTron, HinhVuong, TamGiac. Viết hàm nhận vào một mảng con trỏ lớp cha và trả về tổng diện tích của tất cả các hình.
- Tiêu chí chấm điểm:
  1. Áp dụng đa hình để lấy diện tích của từng đối tượng mà không cần kiểm tra kiểu (if-else).
  2. Xử lý chính xác các tham số toán học cho từng loại hình cụ thể.
  3. Kết quả tổng diện tích phải chính xác theo dữ liệu đầu vào.
  4. Mã nguồn có khả năng mở rộng thêm hình mới (như Hình Thang) mà không cần sửa hàm tính tổng.

Bài 7: Sử dụng Hàm hủy ảo (Virtual Destructor)
- Mô tả: Đây là một lỗi cực kỳ phổ biến và nguy hiểm. Nếu không có hàm hủy ảo, khi xóa một đối tượng lớp con thông qua con trỏ lớp cha, chỉ có phần của lớp cha được giải phóng, gây rò rỉ bộ nhớ.
- Yêu cầu: Tạo lớp cha và lớp con đều có cấp phát bộ nhớ động. Thực hiện giải phóng đối tượng và chứng minh hàm hủy ảo giúp dọn dẹp bộ nhớ hoàn toàn.
- Tiêu chí chấm điểm:
  1. Khai báo virtual cho hàm hủy (Destructor) của lớp cơ sở.
  2. In thông báo trong các hàm hủy để quan sát thứ tự giải phóng bộ nhớ.
  3. Giải phóng bộ nhớ động ở cả hai cấp (cha và con) thành công.
  4. Khắc phục triệt để hiện tượng rò rỉ bộ nhớ (Memory Leak).

Bài 8: Liên kết tĩnh và Liên kết động
- Mô tả: Hiểu rõ sự khác biệt giữa cách trình biên dịch xử lý hàm thông thường (static binding) và hàm ảo (dynamic binding) giúp bạn làm chủ hiệu năng chương trình.
- Yêu cầu: Viết chương trình minh họa cùng một tên hàm nhưng có sự khác biệt về kết quả gọi hàm khi sử dụng con trỏ lớp cha đối với hàm ảo và hàm không ảo.
- Tiêu chí chấm điểm:
  1. Phân biệt được thời điểm quyết định gọi hàm (Compile-time vs Runtime).
  2. Giải thích được cơ chế bảng ảo (V-Table) qua ví dụ thực tế.
  3. Sử dụng đúng cú pháp để ép buộc gọi hàm của lớp cha khi cần thiết.
  4. Đánh giá được chi phí hiệu năng nhỏ của việc sử dụng hàm ảo.

------------------------------------------------------------

PHẦN 3: MỨC ĐỘ KHÓ (HARD)

Bài 9: Thiết kế giao diện (Interface) cho hệ thống thanh toán
- Mô tả: Interface là một dạng lớp trừu tượng đặc biệt chỉ chứa các phương thức thuần ảo, đóng vai trò như một bản cam kết dịch vụ giữa các thành phần phần mềm.
- Yêu cầu: Thiết kế Interface IThanhToan với các phương thức như thucHienGiaoDich(). Cài đặt các lớp cụ thể như ThanhToanThe, ThanhToanViDienTu.
- Tiêu chí chấm điểm:
  1. Xây dựng lớp chỉ chứa các phương thức thuần ảo và không có thuộc tính dữ liệu.
  2. Các lớp dẫn xuất thực thi đầy đủ quy trình của giao dịch thanh toán.
  3. Đảm bảo tính tách biệt giữa giao diện và cài đặt thực tế.
  4. Mô phỏng được một hệ thống thanh toán đa kênh linh hoạt.

Bài 10: Mô phỏng trò chơi chiến thuật với Đa hình
- Mô tả: Trong trò chơi, các nhân vật (Chiến binh, Phù thủy, Cung thủ) đều có hành động "tấn công", nhưng mỗi loại có cách thức và sát thương khác nhau.
- Yêu cầu: Thiết kế lớp trừu tượng NhanVat và các lớp con ghi đè hàm tanCong(). Sử dụng đa hình để thực hiện các đợt tấn công của một đội quân hỗn hợp.
- Tiêu chí chấm điểm:
  1. Quản lý trạng thái và hành vi của nhân vật thông qua các hàm ảo.
  2. Xử lý logic tương tác phức tạp giữa các đối tượng (ví dụ: trừ máu đối phương).
  3. Sử dụng đa hình để tạo ra các hiệu ứng tấn công khác nhau cho từng loại quân.
  4. Mã nguồn thể hiện rõ tư duy thiết kế trò chơi hướng đối tượng.

Bài 11: Hệ thống quản lý lương thưởng phức tạp
- Mô tả: Lương nhân viên không chỉ có lương cơ bản mà còn có thưởng theo doanh số, thưởng theo dự án hoặc phụ cấp độc hại tùy theo vị trí công việc.
- Yêu cầu: Sử dụng lớp trừu tượng và đa hình để thiết kế hệ thống tính lương. Mỗi loại nhân viên có một phương thức tính thưởng riêng biệt được cài đặt đa hình.
- Tiêu chí chấm điểm:
  1. Kết hợp thành công tính kế thừa và tính đa hình trong bài toán thực tế.
  2. Đảm bảo các công thức tính toán phức tạp được đóng gói gọn gàng trong các lớp con.
  3. Tính toán tổng quỹ lương chính xác cho một tổ chức có cơ cấu phức tạp.
  4. Khả năng bảo trì cao khi chính sách thưởng của công ty thay đổi.

Bài 12: Áp dụng Đa hình vào quản lý cửa hàng điện tử
- Mô tả: Một cửa hàng bán Điện thoại, Laptop và Tivi. Mỗi mặt hàng có chế độ bảo hành và khuyến mãi khác nhau. Đa hình giúp xử lý việc thanh toán và in hóa đơn một cách đồng nhất.
- Yêu cầu: Thiết kế hệ thống quản lý sản phẩm với các hàm ảo tinhGiaBan() và hienThiBaoHanh(). Thực hiện in hóa đơn cho một giỏ hàng chứa nhiều loại thiết bị.
- Tiêu chí chấm điểm:
  1. Cài đặt các chiến lược giá và khuyến mãi đa hình cho từng loại sản phẩm.
  2. Xử lý logic in hóa đơn chuyên nghiệp bằng cách duyệt qua danh sách con trỏ lớp cha.
  3. Đảm bảo các đặc tính riêng của sản phẩm vẫn được hiển thị đúng trên hóa đơn.
  4. Hệ thống hoạt động ổn định và dễ dàng thêm mới các mặt hàng kinh doanh khác.


DANH SÁCH BÀI TẬP LẬP TRÌNH HƯỚNG ĐỐI TƯỢNG (OOP)
DẠNG 5: TEMPLATE VÀ XỬ LÝ NGOẠI LỆ
------------------------------------------------------------

PHẦN 1: MỨC ĐỘ DỄ (EASY)

Bài 1: Template hàm tìm giá trị lớn nhất
- Mô tả: Việc viết nhiều hàm tìm số lớn nhất cho kiểu int, kiểu float, kiểu double là rất dư thừa. Template hàm cho phép bạn định nghĩa một logic chung duy nhất để so sánh hai đại lượng cùng kiểu.
- Yêu cầu: Viết một function template tìm giá trị lớn nhất (Max) của hai tham số. Thử nghiệm hàm với các kiểu số nguyên, số thực và ký tự.
- Tiêu chí chấm điểm:
  1. Khai báo đúng cú pháp template <class T> hoặc <typename T>.
  2. Hàm hoạt động chính xác cho ít nhất 3 kiểu dữ liệu khác nhau.
  3. Sử dụng đúng toán tử so sánh bên trong hàm tổng quát.
  4. Trả về đúng kiểu dữ liệu của tham số đầu vào.

Bài 2: Template hàm hoán vị (Swap) hai giá trị
- Mô tả: Hoán vị là thao tác bổ trợ quan trọng trong các thuật toán sắp xếp. Bằng cách dùng template, bạn có thể hoán vị từ hai số nguyên cho đến hai đối tượng Phân số phức tạp.
- Yêu cầu: Xây dựng hàm swap tổng quát. Viết chương trình chính để hoán đổi giá trị của hai số thực và hai ký tự.
- Tiêu chí chấm điểm:
  1. Sử dụng biến trung gian có kiểu dữ liệu T một cách hợp lý.
  2. Truyền tham số dưới dạng tham chiếu (reference) để giá trị thực sự thay đổi sau khi thoát hàm.
  3. Đảm bảo không xảy ra lỗi khi hoán vị các kiểu dữ liệu có kích thước bộ nhớ khác nhau.
  4. Mã nguồn gọn gàng, thể hiện rõ tính tổng quát.

Bài 3: Kiểm soát lỗi chia cho 0 (Exception Handling)
- Mô tả: Trong toán học, phép chia cho 0 là không xác định và sẽ làm chương trình bị "treo" (crash). Cơ chế xử lý ngoại lệ giúp bạn bắt lấy lỗi này và đưa ra thông báo thay vì để chương trình dừng đột ngột.
- Yêu cầu: Viết hàm chia hai số thực. Nếu mẫu số bằng 0, thực hiện ném (throw) một ngoại lệ. Trong hàm main, sử dụng khối try-catch để xử lý.
- Tiêu chí chấm điểm:
  1. Sử dụng lệnh throw để ném đi một thông báo lỗi hoặc một mã lỗi.
  2. Cấu trúc khối try-catch được đặt đúng vị trí cần kiểm soát.
  3. Chương trình vẫn tiếp tục chạy sau khi xử lý xong ngoại lệ.
  4. Thông báo lỗi hiển thị rõ ràng cho người dùng.

Bài 4: Bắt ngoại lệ nhập dữ liệu hình học
- Mô tả: Các kích thước như bán kính hình tròn hay cạnh tam giác không bao giờ được âm. Việc kiểm soát ngay từ khâu nhập giúp đối tượng luôn ở trạng thái hợp lệ.
- Yêu cầu: Trong hàm nhập của lớp HinhTron, nếu người dùng nhập bán kính r <= 0, hãy ném ra một ngoại lệ thông báo dữ liệu không hợp lệ.
- Tiêu chí chấm điểm:
  1. Kiểm tra điều kiện đầu vào ngay trước khi gán giá trị cho thuộc tính.
  2. Ném ra ngoại lệ kiểu chuỗi hoặc kiểu đối tượng exception.
  3. Bắt ngoại lệ trong hàm main và cho phép người dùng nhập lại.
  4. Đảm bảo tính đóng gói không bị phá vỡ bởi dữ liệu sai.

------------------------------------------------------------

PHẦN 2: MỨC ĐỘ TRUNG BÌNH (MEDIUM)

Bài 5: Xây dựng lớp Ngăn xếp tổng quát (Template Stack)
- Mô tả: Một cấu trúc dữ liệu Stack nên dùng được cho mọi loại dữ liệu (lưu số nguyên, lưu sinh viên, lưu phân số). Template lớp cho phép bạn làm điều này một cách dễ dàng.
- Yêu cầu: Định nghĩa lớp template Stack với các phương thức push(), pop(). Thử nghiệm lưu trữ một danh sách các số thực và một danh sách các chuỗi ký tự.
- Tiêu chí chấm điểm:
  1. Khai báo template cho toàn bộ lớp (Class Template).
  2. Quản lý mảng lưu trữ bên trong theo kiểu dữ liệu tổng quát T.
  3. Xử lý được các thao tác cơ bản của Stack với hiệu suất O(1).
  4. Không xảy ra lỗi khi khởi tạo đối tượng với các kiểu dữ liệu khác nhau.

Bài 6: Lớp Mảng động tổng quát (Template Array)
- Mô tả: Thay vì tạo các lớp mảng riêng biệt cho từng kiểu, bạn có thể tạo một lớp mảng duy nhất có khả năng tự co giãn và chứa được bất kỳ kiểu dữ liệu nào.
- Yêu cầu: Viết lớp template MyArray quản lý mảng động. Nạp chồng toán tử [] để truy cập phần tử và viết hàm thêm phần tử vào mảng.
- Tiêu chí chấm điểm:
  1. Quản lý bộ nhớ động (cấp phát/giải phóng) cho kiểu T chính xác.
  2. Toán tử [] trả về đúng kiểu dữ liệu T&.
  3. Xử lý được việc thay đổi kích thước mảng khi vượt quá dung lượng.
  4. Đảm bảo giải phóng bộ nhớ trong hàm hủy của lớp template.

Bài 7: Template hàm sắp xếp mảng (Generic Sort)
- Mô tả: Thuật toán sắp xếp (như Selection Sort) có logic giống nhau cho mọi kiểu dữ liệu, chỉ khác ở phép so sánh. Template hàm sẽ giúp bạn có một hàm sắp xếp "vạn năng".
- Yêu cầu: Viết một hàm template để sắp xếp mảng tăng dần. Thử nghiệm sắp xếp mảng số thực và mảng đối tượng PhanSo (đã nạp chồng toán tử so sánh).
- Tiêu chí chấm điểm:
  1. Logic sắp xếp không phụ thuộc vào một kiểu dữ liệu cụ thể.
  2. Tận dụng được các toán tử đã nạp chồng của các đối tượng phức tạp.
  3. Đảm bảo thuật toán chạy đúng và hiệu quả trên các kiểu dữ liệu khác nhau.
  4. Mã nguồn thể hiện tính tái sử dụng cao.

Bài 8: Bắt nhiều loại ngoại lệ (Multiple Catch Blocks)
- Mô tả: Một đoạn code có thể phát sinh nhiều loại lỗi khác nhau (lỗi chia cho 0, lỗi chỉ số mảng, lỗi hết bộ nhớ). Bạn cần biết cách phân loại để xử lý từng lỗi một cách thích hợp.
- Yêu cầu: Viết chương trình thực hiện tính toán trên mảng. Sử dụng các khối catch khác nhau để bắt lỗi chia cho 0 và lỗi truy cập ngoài phạm vi mảng.
- Tiêu chí chấm điểm:
  1. Thứ tự các khối catch được sắp xếp hợp lý (từ cụ thể đến tổng quát).
  2. Mỗi khối catch đưa ra phản hồi chính xác cho loại lỗi tương ứng.
  3. Sử dụng catch(...) để bắt các lỗi không xác định khác.
  4. Minh họa được luồng đi của chương trình khi gặp từng loại lỗi.

------------------------------------------------------------

PHẦN 3: MỨC ĐỘ KHÓ (HARD)

Bài 9: Lớp Ma trận tổng quát (Template Matrix)
- Mô tả: Ma trận có thể chứa số nguyên, số thực hoặc thậm chí là số phức. Việc dùng template lớp kết hợp với nạp chồng toán tử tạo ra một công cụ toán học cực mạnh.
- Yêu cầu: Xây dựng lớp template Matrix cho phép thực hiện các phép cộng, nhân ma trận giữa các kiểu dữ liệu số học khác nhau.
- Tiêu chí chấm điểm:
  1. Cài đặt thành công các phép toán ma trận trên kiểu dữ liệu tổng quát T.
  2. Xử lý ngoại lệ khi kích thước hai ma trận không tương thích để cộng hoặc nhân.
  3. Quản lý mảng hai chiều động bên trong lớp template một cách an toàn.
  4. Đảm bảo hiệu suất tính toán không bị suy giảm do dùng template.

Bài 10: Xây dựng lớp ngoại lệ tự định nghĩa (Custom Exception)
- Mô tả: Trong các dự án lớn, các thông báo lỗi mặc định là không đủ. Bạn cần tự tạo ra các lớp ngoại lệ riêng kế thừa từ lớp std::exception để mang theo nhiều thông tin lỗi hơn.
- Yêu cầu: Tạo lớp MyException chứa mã lỗi và thông báo lỗi. Sử dụng nó để kiểm soát các tình huống lỗi trong hệ thống quản lý nhân sự (ví dụ: tuổi nhân viên < 18).
- Tiêu chí chấm điểm:
  1. Kế thừa chính xác từ lớp cơ sở std::exception.
  2. Ghi đè (override) phương thức what() để trả về thông báo lỗi tùy chỉnh.
  3. Ném và bắt được đối tượng ngoại lệ tự tạo trong các tình huống thực tế.
  4. Cung cấp đầy đủ thông tin (mã lỗi, thời gian xảy ra lỗi) bên trong đối tượng ngoại lệ.

Bài 11: Danh sách liên kết đơn tổng quát
- Mô tả: Đây là sự kết hợp giữa Cấu trúc dữ liệu và OOP nâng cao. Danh sách liên kết có thể lưu trữ bất kỳ loại Node nào nhờ vào sức mạnh của Template.
- Yêu cầu: Cài đặt lớp template LinkedList. Viết các hàm thêm, xóa, tìm kiếm phần tử. Thử nghiệm lưu trữ danh sách các đối tượng SinhVien.
- Tiêu chí chấm điểm:
  1. Định nghĩa cấu trúc Node bên trong lớp template một cách hợp lý.
  2. Quản lý con trỏ và vùng nhớ động cực kỳ cẩn thận cho kiểu T.
  3. Các phương thức hoạt động ổn định trên cả kiểu dữ liệu cơ bản và kiểu đối tượng.
  4. Giải phóng hoàn toàn bộ nhớ của toàn bộ danh sách trong hàm hủy.

Bài 12: Hệ thống quản lý giỏ hàng kết hợp Template và Exception
- Mô tả: Một hệ thống hoàn chỉnh cần cả sự linh hoạt của Template (để chứa nhiều loại hàng hóa) và sự chặt chẽ của Exception (để kiểm soát kho hàng và thanh toán).
- Yêu cầu: Thiết kế lớp template GioHang. Ném ngoại lệ khi số lượng hàng trong kho không đủ hoặc khi thanh toán vượt quá hạn mức. Sử dụng template để giỏ hàng có thể chứa Sản phẩm điện tử hoặc Thực phẩm.
- Tiêu chí chấm điểm:
  1. Kết hợp nhuần nhuyễn tính đa hình, kế thừa với template trong cùng một hệ thống.
  2. Sử dụng xử lý ngoại lệ để đảm bảo các quy trình nghiệp vụ (business logic) luôn đúng.
  3. Quản lý danh sách hàng hóa trong giỏ hàng bằng lớp template tự xây dựng ở các bài trước.
  4. Mã nguồn chuyên nghiệp, có khả năng mở rộng và chịu lỗi tốt.